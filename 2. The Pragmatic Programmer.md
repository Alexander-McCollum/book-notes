## The Pragmatic Programmer

<details>
<summary><b>A Pragmatic Philosophy</b></summary>
#
- I have agency over where I work and what I do if I'm willing to seek opportunity
- No excuses
  - provide options and explain what can be done if a problem arises
- Don't let problems go unresolved
  - communicate with coworkers
  - actively address issues that arise as they are discovered
- Develop my project visions before discussing them
  - bright ideas must be demonstrated to be so, not explained
  - people will be much more willing to commit resources to your idea if there is a structure for them to build off of
- Don't let minor issues accululate
  - source code cannot be maintained with patches alone
  - root cause analysis will allow for sustainable frameworks
- Recognise when to stop working on something
  - over-engineering or setting impossible requisites are not productive
- Knowing how to learn is more valuable than knowledge itself
  - learn a new programming language every year
  - read a new book every month
  - network to find people who want to talk about topics relevant to whatever I'm studying
- Restrict non-API comments to saying *why* something is done
  - code should already shows *how* it's done
- Be an avid communicator
  - actively listen to my colleagues
  - always respond to emails and messages, even if to inform the other person I will get back to them later
  - know my audience and what I want to communicate to them
  - make my presentations visually appealing
</details>

<details>
<summary><b>A Pragmatic Approach</b></summary>

#
- Make code **easy to change**
  - every piece of knowledge should only have one representation
  - use accessor functions when possible to read and write attributes of objects
- Write **orthogonal** (decoupled) code
  - changes to any one function should not break the functionality of another
  - features should be easy to add, remove, or combine
- Develop **tracer code** to demonstrate a method or structure for a project
  - try to hit very specific goals with the architechture that does no more than prove an idea
  - once the proof-of-concept is made then the project can begin accumulating incremental functionality
- Build a **prototype** for tasks I'm new to or that carry risk
  - the purpose is to learn
  - it does *not* require correctness, completeness, robustness, or style
  - use expedient methods like whiteboards and sticky notes
- Practice making **time estimates** for projects
  - ask people with experience how long similar projects took them
  - develop a model of all the moving parts, define the parameters, and make a best guess
  - take care to use language that compliments the uncertainty
  - continue making estimates interatively as progress is made
  - track all estimates to compare with the final result
</details>

<details>
<summary><b>The Basic Tools</b></summary>

#
- **Plain text** is a very simple and widely used means of data storage
  - it can be easily read by humans and is thereby a good standard
  - virtually every computing tool can operate on plain text
  - it's easy to create version control systems and test
- **Shells** accelerate workflow
  - automate common tasks and write custom scripts
  - doesn't have nearly as many limitations as GUIs do
- Practice **power editing** to speed up repetitive tasks
  - navigate text editors without the use of a mouse
  - find tools to boost efficiency, and build them if they don't exist
- Use **version control** with everything
  - on teams it keeps developers from breaking each others code
  - it times of crisis, it will save numerous hours of restoration
- Practice root cause analysis when **debugging**
  - testing must be systematic and thorough
  - try to reproduce bugs by failing tests before attempting to fix them
  - read all error messages
  - use a binary search method to track down value errors in the stacktrace
  - use *tracing statements* (diagnostic print messages) for real-time, concurrent process, and event-based applications
  - *rubber ducking* is explaining the problem to another person, the act of which alone can help you solve it
  - try process of elimination, first with your code, then dependencies
  - don't assume sections of code work no matter your confidence, prove it does
  - think of what could have been done to prevent the bug and try to make similar bugs easier to handle in the future
  
</details>
